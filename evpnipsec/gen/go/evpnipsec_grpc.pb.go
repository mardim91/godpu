// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2024 Ericsson AB.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.6.1
// source: evpnipsec.proto

package _go

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	IPSec_GetFeatures_FullMethodName = "/godpu.evpnipsec.IPSec/GetFeatures"
	IPSec_GetSPI_FullMethodName      = "/godpu.evpnipsec.IPSec/GetSPI"
	IPSec_AddSA_FullMethodName       = "/godpu.evpnipsec.IPSec/AddSA"
	IPSec_UpdateSA_FullMethodName    = "/godpu.evpnipsec.IPSec/UpdateSA"
	IPSec_QuerySA_FullMethodName     = "/godpu.evpnipsec.IPSec/QuerySA"
	IPSec_DeleteSA_FullMethodName    = "/godpu.evpnipsec.IPSec/DeleteSA"
	IPSec_FlushSAs_FullMethodName    = "/godpu.evpnipsec.IPSec/FlushSAs"
)

// IPSecClient is the client API for IPSec service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IPSecClient interface {
	// Get the feature set supported by this kernel backend.
	//
	// @return                              ORed feature-set of backend
	//
	//	kernel_feature_t (*get_features)(kernel_ipsec_t *this);
	GetFeatures(ctx context.Context, in *Features, opts ...grpc.CallOption) (*Features, error)
	// Get a SPI from the kernel.
	//
	// @param src           source address of SA
	// @param dst           destination address of SA
	// @param protocol      protocol for SA (ESP/AH)
	// @param spi           allocated spi
	// @return              SUCCESS if operation completed
	//
	//	status_t (*get_spi)(kernel_ipsec_t *this, host_t *src, host_t *dst,
	//	                                       uint8_t protocol, uint32_t *spi);
	GetSPI(ctx context.Context, in *GetSPIReq, opts ...grpc.CallOption) (*GetSPIResp, error)
	// Add an SA to the SAD.
	//
	// This function does install a single SA for a single protocol in one
	// direction.
	//
	// @param id                    data identifying this SA
	// @param data                  data for this SA
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*add_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                   kernel_ipsec_add_sa_t *data);
	AddSA(ctx context.Context, in *AddSAReq, opts ...grpc.CallOption) (*AddSAResp, error)
	// Update the hosts on an installed SA.
	//
	// We cannot directly update the destination address as the kernel
	// requires the spi, the protocol AND the destination address (and family)
	// to identify SAs. Therefore if the destination address changed we
	// create a new SA and delete the old one.
	//
	// @param id                    data identifying this SA
	// @param data                  updated data for this SA
	// @return                              SUCCESS if operation completed, NOT_SUPPORTED if
	//
	//	                                            the kernel interface can't update the SA
	//
	//	status_t (*update_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                           kernel_ipsec_update_sa_t *data);
	UpdateSA(ctx context.Context, in *UpdateSAReq, opts ...grpc.CallOption) (*UpdateSAResp, error)
	// Query the number of bytes processed by an SA from the SAD.
	//
	// @param id                    data identifying this SA
	// @param data                  data to query the SA
	// @param[out] bytes    the number of bytes processed by SA
	// @param[out] packets  number of packets processed by SA
	// @param[out] time             last (monotonic) time of SA use
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*query_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                         kernel_ipsec_query_sa_t *data, uint64_t *bytes,
	//	                                         uint64_t *packets, time_t *time);
	QuerySA(ctx context.Context, in *QuerySAReq, opts ...grpc.CallOption) (*QuerySAResp, error)
	// Delete a previously installed SA from the SAD.
	//
	// @param id                    data identifying this SA
	// @param data                  data to delete the SA
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*del_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                    kernel_ipsec_del_sa_t *data);
	DeleteSA(ctx context.Context, in *DeleteSAReq, opts ...grpc.CallOption) (*DeleteSAResp, error)
	// Flush all SAs from the SAD.
	//
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*flush_sas)(kernel_ipsec_t *this);
	FlushSAs(ctx context.Context, in *FlushSAsReq, opts ...grpc.CallOption) (*FlushSAsResp, error)
}

type iPSecClient struct {
	cc grpc.ClientConnInterface
}

func NewIPSecClient(cc grpc.ClientConnInterface) IPSecClient {
	return &iPSecClient{cc}
}

func (c *iPSecClient) GetFeatures(ctx context.Context, in *Features, opts ...grpc.CallOption) (*Features, error) {
	out := new(Features)
	err := c.cc.Invoke(ctx, IPSec_GetFeatures_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecClient) GetSPI(ctx context.Context, in *GetSPIReq, opts ...grpc.CallOption) (*GetSPIResp, error) {
	out := new(GetSPIResp)
	err := c.cc.Invoke(ctx, IPSec_GetSPI_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecClient) AddSA(ctx context.Context, in *AddSAReq, opts ...grpc.CallOption) (*AddSAResp, error) {
	out := new(AddSAResp)
	err := c.cc.Invoke(ctx, IPSec_AddSA_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecClient) UpdateSA(ctx context.Context, in *UpdateSAReq, opts ...grpc.CallOption) (*UpdateSAResp, error) {
	out := new(UpdateSAResp)
	err := c.cc.Invoke(ctx, IPSec_UpdateSA_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecClient) QuerySA(ctx context.Context, in *QuerySAReq, opts ...grpc.CallOption) (*QuerySAResp, error) {
	out := new(QuerySAResp)
	err := c.cc.Invoke(ctx, IPSec_QuerySA_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecClient) DeleteSA(ctx context.Context, in *DeleteSAReq, opts ...grpc.CallOption) (*DeleteSAResp, error) {
	out := new(DeleteSAResp)
	err := c.cc.Invoke(ctx, IPSec_DeleteSA_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPSecClient) FlushSAs(ctx context.Context, in *FlushSAsReq, opts ...grpc.CallOption) (*FlushSAsResp, error) {
	out := new(FlushSAsResp)
	err := c.cc.Invoke(ctx, IPSec_FlushSAs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IPSecServer is the server API for IPSec service.
// All implementations must embed UnimplementedIPSecServer
// for forward compatibility
type IPSecServer interface {
	// Get the feature set supported by this kernel backend.
	//
	// @return                              ORed feature-set of backend
	//
	//	kernel_feature_t (*get_features)(kernel_ipsec_t *this);
	GetFeatures(context.Context, *Features) (*Features, error)
	// Get a SPI from the kernel.
	//
	// @param src           source address of SA
	// @param dst           destination address of SA
	// @param protocol      protocol for SA (ESP/AH)
	// @param spi           allocated spi
	// @return              SUCCESS if operation completed
	//
	//	status_t (*get_spi)(kernel_ipsec_t *this, host_t *src, host_t *dst,
	//	                                       uint8_t protocol, uint32_t *spi);
	GetSPI(context.Context, *GetSPIReq) (*GetSPIResp, error)
	// Add an SA to the SAD.
	//
	// This function does install a single SA for a single protocol in one
	// direction.
	//
	// @param id                    data identifying this SA
	// @param data                  data for this SA
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*add_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                   kernel_ipsec_add_sa_t *data);
	AddSA(context.Context, *AddSAReq) (*AddSAResp, error)
	// Update the hosts on an installed SA.
	//
	// We cannot directly update the destination address as the kernel
	// requires the spi, the protocol AND the destination address (and family)
	// to identify SAs. Therefore if the destination address changed we
	// create a new SA and delete the old one.
	//
	// @param id                    data identifying this SA
	// @param data                  updated data for this SA
	// @return                              SUCCESS if operation completed, NOT_SUPPORTED if
	//
	//	                                            the kernel interface can't update the SA
	//
	//	status_t (*update_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                           kernel_ipsec_update_sa_t *data);
	UpdateSA(context.Context, *UpdateSAReq) (*UpdateSAResp, error)
	// Query the number of bytes processed by an SA from the SAD.
	//
	// @param id                    data identifying this SA
	// @param data                  data to query the SA
	// @param[out] bytes    the number of bytes processed by SA
	// @param[out] packets  number of packets processed by SA
	// @param[out] time             last (monotonic) time of SA use
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*query_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                         kernel_ipsec_query_sa_t *data, uint64_t *bytes,
	//	                                         uint64_t *packets, time_t *time);
	QuerySA(context.Context, *QuerySAReq) (*QuerySAResp, error)
	// Delete a previously installed SA from the SAD.
	//
	// @param id                    data identifying this SA
	// @param data                  data to delete the SA
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*del_sa)(kernel_ipsec_t *this, kernel_ipsec_sa_id_t *id,
	//	                                    kernel_ipsec_del_sa_t *data);
	DeleteSA(context.Context, *DeleteSAReq) (*DeleteSAResp, error)
	// Flush all SAs from the SAD.
	//
	// @return                              SUCCESS if operation completed
	//
	//	status_t (*flush_sas)(kernel_ipsec_t *this);
	FlushSAs(context.Context, *FlushSAsReq) (*FlushSAsResp, error)
	mustEmbedUnimplementedIPSecServer()
}

// UnimplementedIPSecServer must be embedded to have forward compatible implementations.
type UnimplementedIPSecServer struct {
}

func (UnimplementedIPSecServer) GetFeatures(context.Context, *Features) (*Features, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeatures not implemented")
}
func (UnimplementedIPSecServer) GetSPI(context.Context, *GetSPIReq) (*GetSPIResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSPI not implemented")
}
func (UnimplementedIPSecServer) AddSA(context.Context, *AddSAReq) (*AddSAResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSA not implemented")
}
func (UnimplementedIPSecServer) UpdateSA(context.Context, *UpdateSAReq) (*UpdateSAResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSA not implemented")
}
func (UnimplementedIPSecServer) QuerySA(context.Context, *QuerySAReq) (*QuerySAResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySA not implemented")
}
func (UnimplementedIPSecServer) DeleteSA(context.Context, *DeleteSAReq) (*DeleteSAResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSA not implemented")
}
func (UnimplementedIPSecServer) FlushSAs(context.Context, *FlushSAsReq) (*FlushSAsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FlushSAs not implemented")
}
func (UnimplementedIPSecServer) mustEmbedUnimplementedIPSecServer() {}

// UnsafeIPSecServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IPSecServer will
// result in compilation errors.
type UnsafeIPSecServer interface {
	mustEmbedUnimplementedIPSecServer()
}

func RegisterIPSecServer(s grpc.ServiceRegistrar, srv IPSecServer) {
	s.RegisterService(&IPSec_ServiceDesc, srv)
}

func _IPSec_GetFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Features)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecServer).GetFeatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPSec_GetFeatures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecServer).GetFeatures(ctx, req.(*Features))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSec_GetSPI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSPIReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecServer).GetSPI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPSec_GetSPI_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecServer).GetSPI(ctx, req.(*GetSPIReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSec_AddSA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSAReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecServer).AddSA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPSec_AddSA_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecServer).AddSA(ctx, req.(*AddSAReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSec_UpdateSA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSAReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecServer).UpdateSA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPSec_UpdateSA_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecServer).UpdateSA(ctx, req.(*UpdateSAReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSec_QuerySA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySAReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecServer).QuerySA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPSec_QuerySA_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecServer).QuerySA(ctx, req.(*QuerySAReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSec_DeleteSA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSAReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecServer).DeleteSA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPSec_DeleteSA_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecServer).DeleteSA(ctx, req.(*DeleteSAReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPSec_FlushSAs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlushSAsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPSecServer).FlushSAs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPSec_FlushSAs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPSecServer).FlushSAs(ctx, req.(*FlushSAsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// IPSec_ServiceDesc is the grpc.ServiceDesc for IPSec service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IPSec_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "godpu.evpnipsec.IPSec",
	HandlerType: (*IPSecServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetFeatures",
			Handler:    _IPSec_GetFeatures_Handler,
		},
		{
			MethodName: "GetSPI",
			Handler:    _IPSec_GetSPI_Handler,
		},
		{
			MethodName: "AddSA",
			Handler:    _IPSec_AddSA_Handler,
		},
		{
			MethodName: "UpdateSA",
			Handler:    _IPSec_UpdateSA_Handler,
		},
		{
			MethodName: "QuerySA",
			Handler:    _IPSec_QuerySA_Handler,
		},
		{
			MethodName: "DeleteSA",
			Handler:    _IPSec_DeleteSA_Handler,
		},
		{
			MethodName: "FlushSAs",
			Handler:    _IPSec_FlushSAs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "evpnipsec.proto",
}
